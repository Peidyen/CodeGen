
import System
import System.Collections.Generic
import System.IO

namespace CodeConverterInterface
	
	public class SearchHelpers
	
		public static method SearchForExternalSubroutine, @List<SearchResult>
			required in    filespec, string
			required inout allFileContent, String
			required inout sourceLines, @List<String>
			required in    routineNames, @List<String>
		proc
			data results = new List<SearchResult>()

			;;We have a file that contains the name of the routine we're looking for
				
			data ix = -1
			while ((ix+=1) < sourcelines.Count)
			begin
				;;Subroutines:
				;;	Starts with XCALL <whitespace> <routine name>
				;;	Starts with <routine name> <optional whitespace> <open paren>
					
				data tmpString = StringTools.CondenseWhiteSpace(sourcelines[ix].ToUpper().Trim())
				tmpString = " " + StringTools.EnsureSpaceBeforeOpenParen(tmpString) + " "

				data routineName = String.Empty
				foreach routineName in routineNames
				begin
					routineName = routineName.Trim().ToUpper()
					if (tmpString.StartsWith(String.Format(" XCALL {0} ",routineName))) then
						results.Add(new SearchResult() { File=filespec, Token=String.Format("XCALL {0}",routineName), Line= ix + 1})
					else if (tmpString.StartsWith(String.Format(" {0} (",routineName)))
						results.Add(new SearchResult() { File=filespec, Token=String.Format(" {0}()",routineName), Line= ix + 1})
				end
			end

			mreturn results

		endmethod

		public static method SearchForSubroutineOrFunction, @List<SearchResult>
			required in    filespec, string
			required inout allFileContent, String
			required inout sourceLines, @List<String>
			required in    routineNames, @List<String>
		proc
			data results = new List<SearchResult>()
			
			data ix = -1
			while ((ix+=1) < sourcelines.Count)
			begin
				data sourceline, String, sourcelines[ix]
					
				;;Subroutines:
				;;	Starts with XCALL <whitespace> <routine name>
				;;	Starts with <routine name> <optional whitespace> <open paren>
				;;Functions
				;;	Contains % <routine name>
				;;  Contains <routine name> <optional whitespace> <open paren>
					
				data tmpString = " " + StringTools.CondenseWhiteSpace(sourceline.ToUpper().Trim()) + " "

				data routineName = String.Empty
				data token = String.Empty

				foreach routineName in routineNames
				begin
					routineName = routineName.Trim().ToUpper()

					;;TODO: Needs WAY more work. Detecting external function use is really hard!!!

					if (tmpString.StartsWith(token=String.Format(" XCALL {0}",routineName))) then
						results.Add(new SearchResult() {File=filespec, Token=token, Line=ix+1})
					else if (tmpString.StartsWith(token=String.Format(" {0}(",routineName))) then
						results.Add(new SearchResult() {File=filespec, Token=token, Line=ix+1})
					else if (tmpString.StartsWith(token=String.Format(" {0} (",routineName))) then
						results.Add(new SearchResult() {File=filespec, Token=token, Line=ix+1})
					else if (tmpString.Contains(token=String.Format("%{0} ",routineName))) then
						results.Add(new SearchResult() {File=filespec, Token=token, Line=ix+1})
					else if (tmpString.Contains(token=String.Format("{0}(",routineName)))
						results.Add(new SearchResult() {File=filespec, Token=token, Line=ix+1})
				end
			end
			
			mreturn results

		endmethod
		
;		public static method SearchForStatementAndContains, @List<OperationResult>
;			required in  files, @List<String> 
;			required in statement, String
;			required in searchString, String
;			required out summaryMessage, String
;			endparams
;		proc
;			
;			data results, @List<OperationResult>, new List<OperationResult>()
;			data matchingFiles, int, 0
;			data thisFileRecorded, boolean, false
;			
;			data theStatement, String, statement.Trim().ToUpper()
;			data theSearchString, String, searchString.Trim().ToUpper()
;			
;			data sourcefile, String
;			foreach sourcefile in files
;			begin
;				;;Does the file even contain the search string ?
;				data fileContent, String, File.ReadAllText(sourcefile).ToUpper()
;				if (!fileContent.Contains(theStatement) || !fileContent.Contains(theSearchString))
;					nextloop
;				
;				;;We have a file that contains what we're looking for (upper, lower or mixed case)
;				data sourcelines, @List<String>, new List<String>(File.ReadAllLines(sourcefile))
;				thisFileRecorded = false
;				
;				data sourceindex, int, -1
;				while ((sourceindex+=1) < sourcelines.Count)
;				begin
;					data sourceline, String, sourcelines[sourceindex]
;					
;					data tmpString, String, sourceline.Trim().ToUpper()
;					if ((tmpString.StartsWith(theStatement + " ") || tmpString.StartsWith(theStatement + "	")) && tmpString.Contains(theSearchString))
;					begin
;						;;Got one!
;						results.Add(new OperationResult(sourcefile,sourceindex+1,sourceline))
;						if (!thisFileRecorded)
;						begin
;							matchingFiles += 1
;							thisFileRecorded = true
;						end
;					end
;				end
;			end
;			
;			summaryMessage = string.Format("Searched {0} files. Found {1} {2} statements containing {3} in {4} files.",files.Count,results.Count,theStatement,theSearchString,matchingFiles)
;			
;			mreturn results
;			
;		endmethod
		
		public static method SearchForString, @List<SearchResult>
			required in    filespec, string
			required inout allFileContent, String
			required inout sourceLines, @List<String>
			required in    searchStrings, @List<String>
		proc
			data allFileContentUpper = allFileContent.ToUpper()
			data searchString = String.Empty
			data results = new List<SearchResult>()

			foreach searchString in searchStrings
			begin
				searchString = searchString.Trim().ToUpper()

				if (allFileContentUpper.Contains(searchString))
				begin
					data ix = -1
					while ((ix+=1) < sourceLines.Count)
					begin
						if (sourceLines[ix].ToUpper().Contains(searchString))
						begin
							results.Add(new SearchResult() {File=filespec, Token=searchString, Line=ix+1})
						end
					end
				end
			end

			mreturn results
			
		endmethod
		
		public static method SearchForNonPrintableCharacter, @List<SearchResult>
			required in    filespec, string
			required inout allFileContent, String
			required inout sourceLines, @List<String>
			required in    searchCharacter, Char
			required in    displayAs, string
		proc
			data allFileContentUpper = allFileContent.ToUpper()
			data results = new List<SearchResult>()

			if (allFileContent.IndexOf(searchCharacter)!=-1)
			begin
				data ix = -1
				data iy, int
				while ((ix+=1) < sourceLines.Count)
				begin
					iy = sourceLines[ix].IndexOf(searchCharacter)
					if (iy!=-1)
					begin
						results.Add(new SearchResult() {File=filespec, Token=displayAs, Line=ix+1, Position=iy+1})
					end
				end
			end

			mreturn results
			
		endmethod

	endclass
	
	
endnamespace
